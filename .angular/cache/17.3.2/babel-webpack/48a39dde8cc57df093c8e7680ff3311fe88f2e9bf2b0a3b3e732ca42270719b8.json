{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\nconst accountsKey = 'angular-10-signup-verification-boilerplate-accounts';\n// âœ… Clear stored accounts on app/browser startup\nlocalStorage.removeItem(accountsKey);\n// Always start with an empty account list\nlet accounts = [];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          default:\n            return next.handle(request);\n        }\n      }\n      // ===== ROUTE FUNCTIONS =====\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n        if (!account) return error('Email or password is incorrect');\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok({\n          ...basicDetails(account),\n          jwtToken: generateJwtToken(account)\n        });\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok({\n          ...basicDetails(account),\n          jwtToken: generateJwtToken(account)\n        });\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n          return ok();\n        }\n        account.id = newAccountId();\n        account.role = account.id === 1 ? Role.Admin : Role.User;\n        account.dateCreated = new Date().toISOString();\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        if (account.role === Role.Admin) {\n          account.isVerified = true;\n        } else {\n          account.verificationToken = new Date().getTime().toString();\n          account.isVerified = false;\n          setTimeout(() => {\n            const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n            alertService.info(`\n                        <h4>Verification Email</h4>\n                        <p>Thanks for registering!</p>\n                        <p>Please click the below link to verify your email address:</p>\n                        <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                        <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n        }\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        if (!account) return ok();\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password. It will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> This fake backend displayed this \"email\" so you can test without an API.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        const account = accounts.find(x => x.id === idFromUrl());\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) return unauthorized();\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) return error(`Email ${account.email} is already registered`);\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        const params = body;\n        const account = accounts.find(x => x.id === idFromUrl());\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) return unauthorized();\n        if (!params.password) delete params.password;\n        delete params.confirmPassword;\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        const id = idFromUrl();\n        const account = accounts.find(x => x.id === id);\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) return unauthorized();\n        const isDeletingAdmin = account.role === Role.Admin;\n        accounts = accounts.filter(x => x.id !== id);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        if (isDeletingAdmin) {\n          accounts = [];\n          localStorage.setItem(accountsKey, JSON.stringify(accounts));\n          setTimeout(() => location.reload(), 500);\n        }\n        return ok();\n      }\n      // ===== HELPER FUNCTIONS =====\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500));\n      }\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          status,\n          dateCreated,\n          isVerified\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        return account && account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        const authHeader = headers.get('Authorization');\n        if (!authHeader?.startsWith('Bearer fake-jwt-token')) return;\n        const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n        if (Date.now() > jwtToken.exp * 1000) return;\n        return accounts.find(x => x.id === jwtToken.id);\n      }\n      function generateJwtToken(account) {\n        const tokenPayload = {\n          exp: Math.round(Date.now() / 1000) + 15 * 60,\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      function getRefreshToken() {\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n    }\n    static #_ = this.Éµfac = function FakeBackendInterceptor_Factory(t) {\n      return new (t || FakeBackendInterceptor)(i0.ÉµÉµinject(i1.AlertService));\n    };\n    static #_2 = this.Éµprov = /*@__PURE__*/i0.ÉµÉµdefineInjectable({\n      token: FakeBackendInterceptor,\n      factory: FakeBackendInterceptor.Éµfac\n    });\n  }\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}